# Chunk 1
library(tidyverse)
library(patchwork)
library(furrr)
knitr::opts_chunk$set(fig.fullwidth=TRUE, dpi=300, fig.width=7, fig.height=3.5)
# Chunk 2
![](https://media.giphy.com/media/Ju7l5y9osyymQ/giphy.gif)
Rick Astley's fashion sense is like a classic theoretical paper: timeless. Seriously, get a load of that black turtleneck and trousers under a stone trench coat...
# Chunk 3
RickRoll <- function(nt, r, k){
nt1 <- nt * exp(r * (1-nt / k))
return(nt1)
}
RickRollIter <- function(r, k, n0, tf){
data <- rep(n0, tf)
for (t in 1:(length(data)-1)) {
data[t+1] <- RickRoll(nt = data[t], r = r, k = k)
}
res <- tibble(results = data,
timestep = 1:tf)
return(res)
}
# Chunk 4
sim <- tibble(k = 100,
n0 = 50,
tf = 80,
r = c(1.5,2.3,2.6,3.0))
sim
# Chunk 5
sim %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf)))
sim %>%
mutate(results = pmap(.l = list(r, k, n0, tf), .f = RickRollIter))
furrr::future_pmap()
# Chunk 6
sim %>%
unnest(results) %>%
ggplot(aes(x = timestep, y = results)) +
geom_point() +
geom_line() +
facet_wrap(vars(r)) +
ylab("Pop size") +
MCMsBasics::minimal_ggplot_theme()
# Chunk 7
expand_grid(k = c(100, 200, 500),
r = c(1.5, 2.3, 3.0)) %>%
mutate(n0 = 50, tf = 80) %>%
rowwise() %>%
mutate(results = list(
RickRollIter(r = r, k = k, n0 = n0, tf = tf))) %>%
unnest(results) %>%
ggplot(aes(x = timestep, y = results)) +
geom_point() +
geom_line() +
facet_grid(rows = vars(r), cols = vars(k)) +
ylab("Pop size") +
MCMsBasics::minimal_ggplot_theme()
options(future.makeNodePSOCK.setup_strategy = "sequential")
plan(multisession, workers = 2)
microbenchmark::microbenchmark(sim_bf %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bf %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 100,
sim_bf %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 100)
microbenchmark::microbenchmark(sim_bf %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bf %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bf %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 100)
sim_bif <- tibble(k = 100,
n0 = 50,
tf = 1000,
r = seq(from=1.5,to=3.6,by=0.001))
microbenchmark::microbenchmark(sim_bf %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bf %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bf %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 100)
microbenchmark::microbenchmark(sim_bif %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bif %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bif %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 100)
microbenchmark::microbenchmark(sim_bif %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bif %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bif %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
times = 10)
k <- 100 # carrying capacity
n0 <- 50 # starting pop size
tf <- 500 # number of time steps to take
vr <- seq(from=1.5,to=3.6,by=0.001) # creating a vector of r values to use
Nvr <- length(vr) # this is the length of the r value vector
r <- matrix(NA,nrow=tf,ncol=Nvr) # creating an empty matrix with length of the time series,
# and as many columns as r values we'll use
str(r) # checking the structure of the matrix
r[1,] <- rep(n0,Nvr) # putting in our starting value as the first time step entry
microbenchmark::microbenchmark(sim_bif %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bif %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bif %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
for(t in 1:(tf-1)){ # loop through all of the time steps
r[t+1,] <- RickRoll(r[t,],r=vr,k=k) # use the vector of r values
},
times = 10)
r
r2 <- r[(tf-39):tf,] # create a new matrix with only the last 40 time points
str(r2) # check the structure to make sure it worked
plot(vr,r2[1,], pch=".", xlab="r", ylab="pop size") # plot the vector of r values against the first
# set of population sizes and time points
for(i in 2:40) points(vr,r2[i,],pch=".") # use a for loop to plot the rest of the time points
plan(multisession, workers = 4)
microbenchmark::microbenchmark(sim_bif %>%
rowwise() %>%
mutate(results = list(RickRollIter(r = r, k = k, n0 = n0, tf = tf))),
sim_bif %>%
mutate(results = pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
sim_bif %>%
mutate(results = future_pmap(.l = list(k = k, r = r, tf = tf, n0 = n0), .f = RickRollIter)),
for(t in 1:(tf-1)){ # loop through all of the time steps
r[t+1,] <- RickRoll(r[t,],r=vr,k=k) # use the vector of r values
},
times = 10)
expand_grid(k = c(100, 200, 500),
r = c(1.5, 2.3, 3.0)) %>%
mutate(n0 = 50, tf = 80)
d <- expand_grid(k = c(100, 200, 500),
r = c(1.5, 2.3, 3.0)) %>%
mutate(n0 = 50, tf = 80)
d <- expand_grid(k = c(100, 200, 500),
r = c(1.5, 2.3, 3.0)) %>%
mutate(n0 = 50, tf = 80)
d
res <- matrix(NA, nrow = nrow(d), ncol = d$tf[1])
res[,1]
res[,1] <- d$k
res[,1]
res <- matrix(NA, ncol = nrow(d), nrow = d$tf[1])
res[1,] <- d$k
res[1,]
for(t in 1:(d$tf[1]-1)){
r[t+1,] <- RickRoll(r[t,], r=d$r, k=d$k)
}
warnings()
d$r
d$k
res <- matrix(NA, ncol = nrow(d), nrow = d$tf[1])
res[1,] <- d$k
res[1,]
res[2,]
res <- matrix(NA, ncol = nrow(d), nrow = d$tf[1])
res[1,] <- d$k
for(t in 1:(d$tf[1]-1)){
res[t+1,] <- RickRoll(res[t,], r=d$r, k=d$k)
}
res
RickRoll(res[t,], d$r, d$k)
RickRoll <- function(nt, r, k){
nt1 <- nt * exp(r * (1-nt / k))
return(nt1)
}
RickRoll(res[t,], d$r, d$k)
RickRoll(res[t,], d$r, 100)
RickRoll(res[t,], d$r, d$k)
res <- matrix(NA, ncol = nrow(d), nrow = d$tf[1])
res[1,] <- d$n0
RickRoll(res[t,], d$r, d$k)
res <- matrix(NA, ncol = nrow(d), nrow = d$tf[1])
res[1,] <- d$n0
res[1,]
RickRoll(res[t,], d$r, d$k)
for(t in 1:(d$tf[1]-1)){
res[t+1,] <- RickRoll(res[t,], r=d$r, k=d$k)
}
res
r <- c(1,2,3)
tf <- (10,10,15)
r <- c(1,2,3)
tf <- c(10,10,15)
map2(1:length(r), tf, rep(NAtf))
map2(1:length(r), tf, rep(NA, tf))
map2(1:length(r), tf, rep(NA, .y))
map2(.x = 1:length(r), .y = tf, ~rep(NA, .y))
n0 <- c(50, 75, 100)
k <- c(100, 200, 200)
res <- map2(.x = 1:length(r), .y = tf, ~ rep(NA, .y))
res
res[[]][1]
res[[,]][1]
res[1]
res[[1:length(res)]]
res[[]]
res[[1]]
res[[2]]
res[[3]]
res[[1:length(r)]]
res[[1:2]]
res[1:2]
res[1:2][[1]]
map(res, 1)
map(res, 1)[[]]
map(res, 1)
res <- pmap(list(.x = 1:length(r), .y = tf, .z = n0), ~ c(.z, rep(NA, .y-1))
res <- pmap(list(.x = 1:length(r), .y = tf, .z = n0), ~ c(.z, rep(NA, .y-1)))
res <- pmap(list(x = 1:length(r), y = tf, z = n0), ~ c(z, rep(NA, y-1)))
res <- map2(.x = 1:length(r), .y = tf, ~ c(n0, rep(NA, .y-1))
res <- map2(.x = 1:length(r), .y = tf, ~ c(n0, rep(NA, .y-1))
map(res, 1)
res <- map2(.x = 1:length(r), .y = tf, ~ rep(NA, .y))
res
res <- map2(.x = 1:length(r), .y = tf, ~ rep(NA, .y))
res
stack(res)
S <- list(A = c(11,19,14,7), B = c(29,4,1,13,44), C = c(56,9,2,35), D
= c(3,5)); S
stk <- stack(S); stk
RickRollVec <- function(r, k, n0, tf) {
res <- matrix(nrow = length(r), ncol = tf[1])
res[1, ] <- n0
for (t in 1:(d$tf[1] - 1)) {
res[t + 1, ] <- RickRoll(res[t, ], r = r, k = k)
}
}
sim <- tibble(k = 100,
n0 = 50,
tf = 80,
r = c(1.5,2.3,2.6,3.0))
sim
pmap(.l = list(r, k, n0, tf), .f = RickRollVec)
RickRollVec <- function(r, k, n0, tf) {
res <- matrix(nrow = length(r), ncol = tf[1])
res[1, ] <- n0
for (t in 1:(d$tf[1] - 1)) {
res[t + 1, ] <- RickRoll(res[t, ], r = r, k = k)
}
as.list(as.data.frame(res))
}
sim %>%
mutate(test = RickRollVec(r = r, k = k, n0 = n0, tf = tf))
sim %>%
mutate(test = list(RickRollVec(r = r, k = k, n0 = n0, tf = tf)))
